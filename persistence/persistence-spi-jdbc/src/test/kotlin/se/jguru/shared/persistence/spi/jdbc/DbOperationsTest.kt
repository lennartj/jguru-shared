package se.jguru.shared.persistence.spi.jdbc

import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import se.jguru.shared.persistence.spi.jdbc.helpers.Person
import se.jguru.shared.persistence.spi.jdbc.helpers.PersonAndPetView
import se.jguru.shared.persistence.spi.jdbc.helpers.Pet
import java.sql.ResultSet
import java.util.Locale
import java.util.SortedSet
import java.util.TreeMap
import java.util.TreeSet
import java.util.function.BiFunction
import javax.sql.DataSource

class DbOperationsTest : AbstractJdbcTest() {

    override fun createDataSource(): DataSource = createDatabasePool(
        "jdbc:hsqldb:mem:unitTestDB",
        "sa",
        "")

    override fun getInitializeDbStateSqlStatements(): List<String> {

        fun createTable(name: String) = "create table if not exists $name (id int primary key,"
        fun createTable(name: String, incrementBy : Int) = "create table if not exists $name (id int " +
            "generated by default as identity (start with 100, increment by $incrementBy) primary key,"
        fun deleteFromTable(name: String) = "delete from $name"
        fun insertIntoTable(name: String) = "insert into $name values ("

        return listOf(

            // Create the tables
            "${createTable("person")} firstName varchar(64) not null, lastName varchar(64) not null)",
            "${createTable("pet")} petName varchar(64) not null, petType varchar(64) not null)",
            "create table if not exists pet_to_person (personId int, petId int, " +
                "foreign key (personId) references person(id), foreign key (petId) references pet(id), " +
                "constraint jump_id primary key (personId, petId))",
            "${createTable("nickname", 1)} nick varchar(64) not null)",
            "create table if not exists person_to_nickname (person_id int, nickname_id int, " +
                "foreign key (person_id) references person(id), " +
                "foreign key (nickname_id) references nickname(id), " +
                "constraint pk_nickname primary key (person_id, nickname_id))",

            // Truncate each table
            deleteFromTable("person_to_nickname"),
            deleteFromTable("nickname"),
            deleteFromTable("pet_to_person"),
            deleteFromTable("pet"),
            deleteFromTable("person"),

            // Create data within each table
            "${insertIntoTable("pet")} 1, 'fido', 'dog')",
            "${insertIntoTable("pet")} 2, 'pluto', 'cat')",
            "${insertIntoTable("pet")} 3, 'bluppo', 'cat')",
            "${insertIntoTable("person")} 1, 'Lennart', 'Jörelid')",
            "${insertIntoTable("person")} 2, 'Johan', 'Wendels')",
            "${insertIntoTable("pet_to_person")} 1, 2)",
            "${insertIntoTable("pet_to_person")} 2, 1)",
            "${insertIntoTable("pet_to_person")} 2, 3)",
            "insert into nickname (nick) values ('Häxx')",
            "${insertIntoTable("person_to_nickname")} 1, 100)"
        )
    }

    override fun getCleanupDbStateSqlStatements(): List<String> {

        fun dropTable(name: String) = "drop table $name cascade"

        return listOf(

            // Drop the tables
            dropTable("person_to_nickname"),
            dropTable("nickname"),
            dropTable("pet_to_person"),
            dropTable("pet"),
            dropTable("person")
        )
    }

    @Test
    fun validateGettingDatabaseMetadata() {

        // Assemble
        val expected = listOf("PERSON", "PET", "PET_TO_PERSON", "NICKNAME", "PERSON_TO_NICKNAME")

        // Act
        val databaseMetadata = doInConnection { it.metaData }
        val tablesRS = databaseMetadata.getTables(null, null, "%", arrayOf("TABLE"))

        val tableNames = mutableListOf<String>()
        while (tablesRS.next()) {
            tableNames.add(tablesRS.getString(3))
        }

        // Assert
        assertThat(databaseMetadata).isNotNull
        expected.forEach {
            assertThat(expected).contains(it.uppercase(Locale.ENGLISH))
        }
    }

    @Test
    fun validateReadingData() {

        // Assemble
        val sql = "select id, firstName, lastName from person order by id"
        val personConverter = { rs: ResultSet, _: Int ->

            val id = DbOperations.getIntOrNull(1, rs)
            val firstName = rs.getString(2)
            val lastName = rs.getString(3)

            Person(id!!, firstName, lastName)
        }

        val javaTypedPersonConverter = BiFunction<ResultSet, Int, Person?> { rs, index -> personConverter.invoke(rs, index) }

        // Act
        val people = DbOperations.readAndConvert(dataSource, sql, personConverter).associateBy { it.id }
        val javaPeople = DbOperations.readAndConvert(dataSource, sql, javaTypedPersonConverter).associateBy { it.id }

        // Assert
        assertThat(people.size).isEqualTo(2)
        assertThat(javaPeople.size).isEqualTo(2)

        assertThat(people[1]?.lastName).isEqualTo("Jörelid")
        assertThat(people[2]?.lastName).isEqualTo("Wendels")

        assertThat(javaPeople[1]?.lastName).isEqualTo("Jörelid")
        assertThat(javaPeople[2]?.lastName).isEqualTo("Wendels")
    }

    @Test
    fun validateInsertingData() {

        // Assemble
        val petInsertSQL = "insert into pet (id, petName, petType) values (?, ?, ?)"
        val ownerInsertSQL = "insert into pet_to_person (personId, petId) values (?, ?)"

        val dogs = (10..19).map { Pet(it, "Fluffy_$it", "dog") }
        val owners = (10..19).map { Pair(1, it) }

        // Act
        val insertPetMetadata = DbOperations.insertOrUpdate(dataSource, petInsertSQL, dogs) { arrayOf(it.id, it.name, it.type) }
        val insertOwnersMetadata = DbOperations.insertOrUpdate(dataSource, ownerInsertSQL, owners)
        { arrayOf(it.first, it.second) }

        // Assert
        assertThat(insertPetMetadata.numRowsAffected).isEqualTo(10)
        assertThat(insertOwnersMetadata.numRowsAffected).isEqualTo(10)

        val db = getDbStructure()
        assertThat(db.size).isEqualTo(2)

        val personWithManyPets = db.first { it.id == 1 }
        assertThat(personWithManyPets.pets.size).isEqualTo(11)
    }

    @Test
    fun validateInsertingDataWithAutogeneratedPKs() {

        // Assemble
        val nickInsertSQL = "insert into nickname (nick) values (?)"
        val nicks = listOf("Tjabo", "Fleptut")

        // Act
        val insertNicknamesMetadata = DbOperations.insertOrUpdate(dataSource, nickInsertSQL, nicks, arrayOf("id"))
        { arrayOf(it) }

        // Assert
        assertThat(insertNicknamesMetadata.numRowsAffected).isEqualTo(2)

        val genPKs = insertNicknamesMetadata.generatedPrimaryKeys
        assertThat(genPKs.size).isEqualTo(2)

        assertThat(genPKs.toTypedArray()).containsExactlyElementsOf(listOf(101, 102))
    }

    @Test
    fun validateUpdatingData() {

        // Assemble
        val ownerUpdateSQL = "update person set firstName = ?, lastName = ? where id = ?"
        val updatedOwnerValues = listOf(Person(1, "Fleptut", "Jörelid"))

        // Act
        val updateMetadata = DbOperations.update(dataSource, ownerUpdateSQL, updatedOwnerValues)
        { arrayOf(it.firstName, it.lastName, it.id) }

        // Assert
        assertThat(updateMetadata.numRowsAffected).isEqualTo(1)

        val db = getDbStructure()
        assertThat(db.size).isEqualTo(2)

        val theLennart = db.first { it.id == 1 }
        assertThat(theLennart.firstName).isEqualTo("Fleptut")
        assertThat(theLennart.lastName).isEqualTo("Jörelid")
    }

    //
    // Private helpers
    //

    private fun getDbStructure(): SortedSet<Person> {

        val sql = "select p.id, p.firstName, p.lastName, pet.id, pet.petName, pet.petType from person p " +
            "join pet_to_person ptp on p.id = ptp.personId " +
            "join pet on pet.id = ptp.petId " +
            "order by p.id, pet.id"

        val personAndPetConverter = { rs: ResultSet, _: Int ->

            val personId = DbOperations.getIntOrNull(1, rs)
            val firstName = rs.getString(2)
            val lastName = rs.getString(3)
            val petId = DbOperations.getIntOrNull(4, rs)
            val petName = rs.getString(5)
            val petType = rs.getString(6)

            PersonAndPetView(personId!!, firstName, lastName, petId!!, petName, petType)
        }

        val ppView = DbOperations.readAndConvert(dataSource, sql, personAndPetConverter)
        val personMap = TreeMap<Int, Person>()

        ppView.forEach {

            val person = when (personMap[it.personId] == null) {
                false -> personMap[it.personId]!!
                else -> {

                    val person = Person(it.personId, it.firstName, it.lastName)
                    personMap[person.id] = person
                    person
                }
            }

            person.pets.add(Pet(it.petId, it.petName, it.petType))
        }

        val toReturn = TreeSet<Person>()
        toReturn.addAll(personMap.values)

        return toReturn
    }
}
