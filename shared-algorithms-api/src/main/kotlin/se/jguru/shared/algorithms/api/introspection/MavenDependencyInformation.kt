package se.jguru.shared.algorithms.api.introspection

import java.io.Serializable
import java.util.SortedMap

/**
 * Simplified enum containing permitted Maven dependency scopes.
 *
 * @author [Lennart J&ouml;relid](mailto:lj@jguru.se), jGuru Europe AB
 */
enum class DependencyScope : Serializable {

    COMPILE,

    PROVIDED,

    RUNTIME,

    TEST,

    SYSTEM,

    IMPORT;

    /**
     * The maven value of this [DependencyScope]
     */
    val mavenValue = name.toLowerCase()
}

/**
 * Simplified dependency information as parsed from a Maven dependency.properties file.
 *
 * @param groupID The Maven artifact groupID
 * @param artifactID The Maven artifactId
 * @param mavenVersion The Maven version
 * @param scope The Maven dependency scope
 *
 * @author [Lennart J&ouml;relid](mailto:lj@jguru.se), jGuru Europe AB
 */
class MavenDependencyInformation(val groupID: String,
                                 val artifactID: String,
                                 val mavenVersion: String,
                                 val scope: DependencyScope) : Serializable {

    companion object {

        /**
         * The standard path of the `dependencies.properties` file containing maven GAV information.
         */
        const val DEPENDENCY_RESOURCE = "META-INF/maven/dependencies.properties"

        /**
         * Synthesizes a MavenDependencyInformation object from the data supplied within the [dependencyMap], which
         * adheres to the format generated by the depends-maven-plugin. This typically means that the [dependencyMap]
         * contains triplets of entries on the following form:
         *
         * * javax.validation/validation-api/version = 1.1.0.Final
         * * javax.validation/validation-api/type = jar
         * * javax.validation/validation-api/scope = provided
         */
        @JvmStatic
        fun parse(groupID: String, artifactID: String, dependencyMap: Map<String, String>)
            : MavenDependencyInformation {

            // Extract the required keys
            val keyPrefix = groupID + "/" + artifactID
            val versionKey = keyPrefix + "/version"
            val scopeKey = keyPrefix + "/scope"

            // Fetch the required data
            val mavenVersion = dependencyMap[versionKey]
            val scopeString = dependencyMap[scopeKey]

            // Ensure that the required data exists
            if (mavenVersion == null) {
                throw IllegalArgumentException("Could not find a Maven version for Group/Artifact " +
                    "[$groupID/$artifactID]")
            }
            if (scopeString == null) {
                throw IllegalArgumentException("Could not find a Maven scope for Group/Artifact " +
                    "[$groupID/$artifactID]")
            }

            // Check sanity on the scope value
            val scope = DependencyScope.values().filter { it.mavenValue.equals(scopeString, true) }
            if (scope.size != 1) {
                throw IllegalArgumentException("Could not interpret Maven scope for Group/Artifact " +
                    "[$groupID/$artifactID]. Found: $scopeString, Required one of: " +
                    DependencyScope.values().map { it.mavenValue }.reduce { l, r -> l + ", " + r })
            }

            // All Done.
            return MavenDependencyInformation(groupID, artifactID, mavenVersion, scope.first())
        }

        /**
         * Parses all
         */
        @JvmStatic
        fun parse(dependencyMap: Map<String, String>): Set<MavenDependencyInformation> {

            val toReturn = mutableSetOf<MavenDependencyInformation>()

            // ch.qos.logback/logback-core/version = 1.2.2
            val versionKeySuffix = "/version"
            val separator = "/"

            dependencyMap.entries
                .filter { it.key.endsWith(versionKeySuffix) }
                .map { entry ->

                    val keyPrefix = entry.key.substring(0, entry.key.indexOf(versionKeySuffix)).trim()
                    val slashIndex = keyPrefix.indexOf(separator)

                    // Split the key into the groupID and artifactID
                    Pair(
                        keyPrefix.substring(0, slashIndex),
                        keyPrefix.substring(slashIndex + separator.length))

                }.map {

                    try {
                        parse(it.first, it.second, dependencyMap)
                    } catch (e: Exception) {
                        // Ignore this Exception
                        null
                    }
                }.forEach { if (it != null) toReturn.add(it) }

            // All Done.
            return toReturn
        }
    }
}